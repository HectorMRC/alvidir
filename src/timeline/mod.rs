#[cfg(feature = "in_memory")]
pub mod repository;
pub mod service;

mod error;
use std::collections::{HashMap, HashSet};

pub use error::*;

use crate::{id::Id, interval::Interval, name::Name};

/// MomentName determines an instance of [Name] belongs to a [Moment].
#[derive(Clone, PartialEq, Eq)]
pub struct MomentName;

/// A Moment answers the "when", giving the order of time.
#[derive(Clone)]
pub struct Moment {
    name: Name<MomentName>,
    /// the position of self in a list of consecutive moments.
    index: usize,
}

impl Eq for Moment {}
impl PartialEq for Moment {
    fn eq(&self, other: &Self) -> bool {
        self.index == other.index
    }
}

impl PartialOrd for Moment {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.index.partial_cmp(&other.index)
    }
}

impl Ord for Moment {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.index.cmp(&other.index)
    }
}

/// A Period is the time being between two different [Moment]s in time. Both included.
#[derive(Clone)]
pub struct Period([Moment; 2]);

impl Interval for Period {
    type Bound = Moment;

    fn lo(&self) -> Self::Bound {
        self.0[0].clone()
    }

    fn hi(&self) -> Self::Bound {
        self.0[1].clone()
    }
}

/// TimelineId determines an instance of [Id] belongs to a [Timeline].
#[derive(Hash, PartialEq, Eq)]
pub struct TimelineId;

/// TimelineName determines an instance of [Name] belongs to a [Timeline].
pub struct TimelineName;

/// A Timeline is an ordered collection of moments.
pub struct Timeline {
    id: Id<TimelineId>,
    name: Name<TimelineName>,
    moments: Vec<Moment>,
}

impl Timeline {
    /// Creates a new timeline with the given name and an autogenerated id.
    pub fn new(name: Name<TimelineName>) -> Self {
        Self {
            id: Id::new(),
            name,
            moments: Default::default(),
        }
    }

    /// Creates a new timeline with the given id and name.
    pub fn with_id(id: Id<TimelineId>, name: Name<TimelineName>) -> Self {
        Self {
            id,
            name,
            moments: Default::default(),
        }
    }

    /// Pushes the given moment at the end of the timeline.
    pub fn push_moment(&mut self, mut moment: Moment) -> Result<()> {
        if self
            .moments
            .iter()
            .map(|moment| moment.name.as_ref())
            .any(|name| name == moment.name.as_ref())
        {
            return Err(Error::MomentAlreadyExists);
        }

        moment.index = self.moments.len();
        self.moments.push(moment);
        Ok(())
    }
}
